	double old_x;
	double old_y;

	old_x = mlx->player->player_x;
	old_y = mlx->player->player_y;
	if (mlx->player->key_w)
	{
		if (mlx->pars->map[(int)(((mlx->player->player_y + (MOVE_SPEED + 4) * sin(mlx->player->player_angle)) + TILE_LEN / 2)/ TILE_LEN)]\
		[(int)((old_x + TILE_LEN / 2) / TILE_LEN)] != '1')
			mlx->player->player_y += MOVE_SPEED * sin(mlx->player->player_angle);

		if (mlx->pars->map[(int)((old_y + TILE_LEN / 2) / TILE_LEN)]\
		[(int)(((mlx->player->player_x + ((MOVE_SPEED + 4) * cos(mlx->player->player_angle))) + TILE_LEN / 2) / TILE_LEN)] != '1')
			mlx->player->player_x += MOVE_SPEED * cos(mlx->player->player_angle);
	}
	else if (mlx->player->key_s)
	{
		if (mlx->pars->map[(int)(((mlx->player->player_y - ((MOVE_SPEED + 4) * sin(mlx->player->player_angle))) + TILE_LEN / 2)/ TILE_LEN)]\
		[(int)((old_x + TILE_LEN / 2) / TILE_LEN)] != '1')
        	mlx->player->player_y -= MOVE_SPEED * sin(mlx->player->player_angle);

		if (mlx->pars->map[(int)((old_y + TILE_LEN / 2) / TILE_LEN)]\
		[(int)(((mlx->player->player_x - ((MOVE_SPEED + 4) * cos(mlx->player->player_angle))) + TILE_LEN / 2) / TILE_LEN)] != '1')
        	mlx->player->player_x -= MOVE_SPEED * cos(mlx->player->player_angle);

	}
	if (mlx->player->key_a)
	{
		if (mlx->pars->map[(int)(((mlx->player->player_y - ((MOVE_SPEED + 4) * cos(mlx->player->player_angle))) + TILE_LEN / 2)/ TILE_LEN)]\
		[(int)((old_x + TILE_LEN / 2) / TILE_LEN)] != '1')
        	mlx->player->player_y -= MOVE_SPEED * cos(mlx->player->player_angle);

		if (mlx->pars->map[(int)((old_y + TILE_LEN / 2) / TILE_LEN)]\
		[(int)((mlx->player->player_x + ((MOVE_SPEED + 4) * sin(mlx->player->player_angle)) + TILE_LEN / 2) / TILE_LEN)] != '1')
        	mlx->player->player_x += MOVE_SPEED * sin(mlx->player->player_angle);
	}
	else if (mlx->player->key_d)
	{
		if (mlx->pars->map[(int)(((mlx->player->player_y + ((MOVE_SPEED + 4) * cos(mlx->player->player_angle))) + TILE_LEN / 2)/ TILE_LEN)]\
		[(int)((old_x + TILE_LEN / 2) / TILE_LEN)] != '1')
        	mlx->player->player_y += MOVE_SPEED * cos(mlx->player->player_angle);

		if (mlx->pars->map[(int)((old_y + TILE_LEN / 2) / TILE_LEN)]\
		[(int)(((mlx->player->player_x - ((MOVE_SPEED + 4) * sin(mlx->player->player_angle))) + TILE_LEN / 2) / TILE_LEN)] != '1')
        	mlx->player->player_x -= MOVE_SPEED * sin(mlx->player->player_angle);

	}
	if (mlx->player->key_left)
        mlx->player->player_angle -= ROT_SPEED;
	else if (mlx->player->key_right)
	   	mlx->player->player_angle += ROT_SPEED;